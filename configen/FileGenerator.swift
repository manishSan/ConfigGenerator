 //
 //  FileGenerator.swift
 //  configen
 //
 //  Created by Dónal O'Brien on 11/08/2016.
 //  Copyright © 2016 The App Business. All rights reserved.
 //

 import Foundation

 struct FileGenerator {

    //let optionsParser: OptionsParser
    let input: FileGeneratorInput

    let options: OptionsParser

    var autoGenerationComment: String { return "// auto-generated by \(input.appName)\n// to add or remove properties, edit the mapping file'.\n// README: https://github.com/theappbusiness/ConfigGenerator/blob/master/README.md\n// timestamp: \(Date())\n\n" }

    func generateHeaderFile(withTemplate template: HeaderTemplate) {

        var headerBodyContent = ""
        for (variableName, type) in input.hintsDictionary {
            let headerLine = methodDeclarationForVariableName(variableName, type: type, template: template)
            headerBodyContent.append("\n" + headerLine + ";" + "\n")
        }

        var headerBody = template.headerBody
        headerBody.replace(template.bodyToken, withString: headerBodyContent)


        write(header: autoGenerationComment,
              imports: template.headerImportStatements,
              content: headerBody,
              toFile: template.outputHeaderFileName)
    }

    func deleteFile(_ fileName: String) {
        if FileManager.default.fileExists(atPath: fileName) {
            do {
                try FileManager.default.removeItem(atPath: fileName)
            } catch {
                fatalError("Failed to delete file at path \(fileName)")
            }
        }
    }

    func generateImplementationFile(withTemplate template: ImplementationTemplate) {
        let body = generateImplementationBody(template) { (name, generator) in
            let template = ObjectiveCTemplate(outClassDir: parser.outputClassDirectory,
                                              outClassName: name,
                                              outFileName: parser.outputClassName)
            generator.generateImplementationFile(withTemplate: template)
        }

        write(header: autoGenerationComment,
              imports: template.implementationImportStatements,
              content: body,
              toFile: template.outputImplementationFileName)
    }

    func generateSwiftFile(withTemplate template: ImplementationTemplate) {
        let body = generateImplementationBody(template) { (name, generator) in
            let template = SwiftTemplate(outClassDir: parser.outputClassDirectory,
                                         outClassName: name,
                                         outFileName: parser.outputClassName)
            generator.generateSwiftFile(withTemplate: template)
        }

        write(header: autoGenerationComment,
              imports: template.implementationImportStatements,
              content: body,
              toFile: template.outputImplementationFileName)
    }

    private func generateImplementationBody(_ template: ImplementationTemplate,
                                            innerFileGeneratorClosure: @escaping (String, FileGenerator) -> Void) -> String {
        var implementationBodyContent = ""
        for (variableName, type) in input.hintsDictionary {
            let implementationLine = methodImplementationForVariableName(variableName,
                                                                         type: type,
                                                                         template: template,
                                                                         innerFileGeneratorClosure: innerFileGeneratorClosure)
            implementationBodyContent.append("\n" + implementationLine + "\n")
        }

        var implementationBody = template.implementationBody
        implementationBody.replace(template.bodyToken, withString: implementationBodyContent)
        return implementationBody
    }

    private func write(header: String, imports: String, content: String, toFile: String) {
        do {
            if FileManager.default.fileExists(atPath: toFile) {
                let fileURL = URL(fileURLWithPath: toFile)
                let implementationOutputString = "\n" + content
                if let outputStream = OutputStream(url: fileURL, append: true) {
                    outputStream.open()

                    let bytesWritten = outputStream.write(implementationOutputString, maxLength: implementationOutputString.characters.count)
                    if bytesWritten < 0 { fatalError("write failure - \(toFile)")  }
                    outputStream.close()
                } else {
                    fatalError("Unable to open file - \(toFile)")
                }
            } else {
                /// create new file
                let implementationOutputString = header + imports + content
                try implementationOutputString.write(toFile: toFile, atomically: true, encoding: String.Encoding.utf8)
            }
        }
        catch {
            fatalError("Failed to write to file at path \(toFile)")
        }
    }


    func methodDeclarationForVariableName(_ variableName: String, type: String, template: HeaderTemplate) -> String {
        var line = ""
        var variable = variableName

        switch (type) {
        case ("Double"):
            line = template.doubleDeclaration

        case ("Int"):
            line = template.integerDeclaration

        case ("String"):
            line = template.stringDeclaration

        case ("Bool"):
            line = template.booleanDeclaration

        case ("URL"):
            line = template.urlDeclaration

        case ("Dictionary"):
            /// generate a new custom class here
            if let dict = input.inputDictionary[variableName] as? Dictionary<String, AnyObject>,
                let hints = options.hints(variableName) {
                let a = FileGeneratorInput(appName: input.appName,
                                           inputDictionary: dict,
                                           hintsDictionary: hints,
                                           outputClass: variableName,
                                           outputFile: input.outputFile)
                let generator = FileGenerator(input: a, options: options)

                let innerTemplate = ObjectiveCTemplate(outClassDir: parser.outputClassDirectory,
                                                       outClassName: variableName,
                                                       outFileName: parser.outputClassName)

                generator.generateHeaderFile(withTemplate: innerTemplate)
                generator.generateImplementationFile(withTemplate: innerTemplate)

                line = template.customClassDeclaration
                variable = variableName.lowercased()
                line.replace(template.customTypeToken, withString: variableName)

                variable = variableName.lowercased()
            }
        default:
            line = template.customDeclaration
            line.replace(template.customTypeToken, withString: type)
        }

        line.replace(template.variableNameToken, withString: variable)

        return line
    }

    func methodImplementationForVariableName(_ variableName: String,
                                             type: String,
                                             template: ImplementationTemplate,
                                             innerFileGeneratorClosure: (String, FileGenerator) -> Void) -> String {

        guard let value = input.inputDictionary[variableName] else {
            fatalError("No configuration setting for variable name: \(variableName)")
        }

        var line = ""
        var variable = variableName
        var addValue = true

        switch (type) {
        case ("Double"):
            line = template.doubleImplementation

        case ("Int"):
            line = template.integerImplementation

        case ("String"):
            line = template.stringImplementation

        case ("Bool"):
            let boolString = value as! Bool ? template.trueString : template.falseString
            line = template.booleanImplementation
            line.replace(template.valueToken, withString: boolString)

        case ("URL"):
            let url = URL(string: "\(value)")!
            guard url.host != nil else {
                fatalError("Found URL without host: \(url) for setting: \(variableName)")
            }
            line = template.urlImplementation

        case ("Dictionary"):
            /// create a class with key
            /// pass value as the dictionary to process
            if let dict = value as? Dictionary<String, AnyObject>, let hints = options.hints(variableName) {
                let a = FileGeneratorInput(appName: input.appName,
                                           inputDictionary: dict,
                                           hintsDictionary: hints,
                                           outputClass: variableName,
                                           outputFile: input.outputFile)

                innerFileGeneratorClosure(variableName, FileGenerator(input: a, options: options))

                line = template.customInstantiation
                line.replace(template.customTypeToken, withString: variableName)
                variable = variableName.lowercased()
                addValue = false
            }

        default:
            guard value is String else {
                fatalError("Value (\(value)) must be a string in order to be used by custom type \(type)")
            }
            line = template.customImplementation
            line.replace(template.customTypeToken, withString: type)
        }

        line.replace(template.variableNameToken, withString: variable)
        if addValue {
            line.replace(template.valueToken, withString: "\(value)")
        }

        return line
    }

 }

 extension String {
    mutating func replace(_ token: String, withString string: String) {
        self = replacingOccurrences(of: token, with: string)
    }

    var trimmed: String {
        return (self as NSString).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }
 }


