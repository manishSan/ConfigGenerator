 //
 //  FileGenerator.swift
 //  configen
 //
 //  Created by Dónal O'Brien on 11/08/2016.
 //  Copyright © 2016 The App Business. All rights reserved.
 //

 import Foundation

 struct FileGenerator {

    //let optionsParser: OptionsParser
    let input: FileGeneratorInput

    let options: OptionsParser

    var autoGenerationComment: String { return "// auto-generated by \(input.appName)\n// to add or remove properties, edit the mapping file'.\n// README: https://github.com/theappbusiness/ConfigGenerator/blob/master/README.md\n//timestamp: \(Date())\n\n" }

    func generateHeaderFile(withTemplate template: HeaderTemplate) {

        var headerBodyContent = ""
        for (variableName, type) in input.hintsDictionary {
            let headerLine = methodDeclarationForVariableName(variableName: variableName, type: type, template: template)
            headerBodyContent.append("\n" + headerLine + ";" + "\n")
        }

        var headerBody = template.headerBody
        headerBody.replace(token: template.bodyToken, withString: headerBodyContent)

        do {
            let headerOutputString = autoGenerationComment + template.headerImportStatements + headerBody
            try headerOutputString.write(toFile: template.outputHeaderFileName, atomically: true, encoding: String.Encoding.utf8)
        }
        catch {
            fatalError("Failed to write to file at path \(template.outputHeaderFileName)")
        }

    }


    func generateImplementationFile(withTemplate template: ImplementationTemplate) {
        var implementationBodyContent = ""
        for (variableName, type) in input.hintsDictionary {
            let implementationLine = methodImplementationForVariableName(variableName: variableName, type: type, template: template)
            implementationBodyContent.append("\n" + implementationLine + "\n")
        }

        var implementationBody = template.implementationBody
        implementationBody.replace(token: template.bodyToken, withString: implementationBodyContent)

        do {
            let implementationOutputString = autoGenerationComment + template.implementationImportStatements + implementationBody
            try implementationOutputString.write(toFile: template.outputImplementationFileName, atomically: true, encoding: String.Encoding.utf8)
        }
        catch {
            fatalError("Failed to write to file at path \(template.outputImplementationFileName)")
        }

    }


    func methodDeclarationForVariableName(variableName: String, type: String, template: HeaderTemplate) -> String {
        var line = ""
        var variable = variableName

        switch (type) {
        case ("Double"):
            line = template.doubleDeclaration

        case ("Int"):
            line = template.integerDeclaration

        case ("String"):
            line = template.stringDeclaration

        case ("Bool"):
            line = template.booleanDeclaration

        case ("URL"):
            line = template.urlDeclaration

        case ("Dictionary"):
            /// generate a new custom class here
            if let dict = input.inputDictionary[variableName] as? Dictionary<String, AnyObject>,
                let hints = options.hints(key: variableName) {
                let a = FileGeneratorInput(appName: input.appName,
                                           inputDictionary: dict,
                                           hintsDictionary: hints,
                                           outputClass: variableName)
                let generator = FileGenerator(input: a, options: options)

                let innerTemplate = ObjectiveCTemplate(outClassDir: parser.outputClassDirectory,
                                                       outClassName: variableName)

                generator.generateHeaderFile(withTemplate: innerTemplate)
                generator.generateImplementationFile(withTemplate: innerTemplate)

                line = template.customClassDeclaration
                variable = variableName.lowercased()
                line.replace(token: template.customTypeToken, withString: variableName)

                variable = variableName.lowercased()
            }
        default:
            line = template.customDeclaration
            line.replace(token: template.customTypeToken, withString: type)
        }

        line.replace(token: template.variableNameToken, withString: variable)

        return line
    }


    func methodImplementationForVariableName(variableName: String, type: String, template: ImplementationTemplate) -> String {

        guard let value = input.inputDictionary[variableName] else {
            fatalError("No configuration setting for variable name: \(variableName)")
        }

        var line = ""
        var variable = variableName
        var addValue = true

        switch (type) {
        case ("Double"):
            line = template.doubleImplementation

        case ("Int"):
            line = template.integerImplementation

        case ("String"):
            line = template.stringImplementation

        case ("Bool"):
            let boolString = value as! Bool ? template.trueString : template.falseString
            line = template.booleanImplementation
            line.replace(token: template.valueToken, withString: boolString)

        case ("URL"):
            let url = URL(string: "\(value)")!
            guard url.host != nil else {
                fatalError("Found URL without host: \(url) for setting: \(variableName)")
            }
            line = template.urlImplementation

        case ("Dictionary"):
            /// create a class with key
            /// pass value as the dictionary to process
            if let dict = value as? Dictionary<String, AnyObject>, let hints = options.hints(key: variableName) {
                let a = FileGeneratorInput(appName: input.appName,
                                           inputDictionary: dict,
                                           hintsDictionary: hints,
                                           outputClass: variableName)
                let generator = FileGenerator(input: a, options: options)

                let innerTemplate = SwiftTemplate(outClassDir: options.outputClassDirectory,
                                                  outClassName: variableName)
                generator.generateImplementationFile(withTemplate: innerTemplate)

                line = template.customInstantiation
                line.replace(token: template.customTypeToken, withString: variableName)
                variable = variableName.lowercased()
                addValue = false
            }

        default:
            guard value is String else {
                fatalError("Value (\(value)) must be a string in order to be used by custom type \(type)")
            }
            line = template.customImplementation
            line.replace(token: template.customTypeToken, withString: type)
        }

        line.replace(token: template.variableNameToken, withString: variable)
        if addValue {
            line.replace(token: template.valueToken, withString: "\(value)")
        }

        return line
    }

 }

 extension String {
    mutating func replace(token: String, withString string: String) {
        self = replacingOccurrences(of: token, with: string)
    }

    var trimmed: String {
        return (self as NSString).trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }
 }


